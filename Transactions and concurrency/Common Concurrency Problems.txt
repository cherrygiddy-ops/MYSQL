1.Lost Updates ->Two Transactions Trying to Update Same Data and we did  not used Locks hence transactions commits later will override the changes of previous transactions -> solution is to used locks
2.Dirty Reads -> when a transaction reads data has not been committed yet solution is to provide the level of isolation around our transactions i.e. Isolation level of Read Committed
3.Non-Repeating Reads ->Reading Something Twice and getting different results -> Solution is to read the currently updated Transaction or provide Isolation level of Repeatable Reads.
4.Phantoms Reads ->Data That's Magically Appears after Executing a Query -> solution is  if its importance then make sure no updates to take place till that transaction commits -> Isolation level is Serializable this is guarantying that transaction will be aware of changes currently being made by other transactions to the data. Transactions will be executed sequentially and this mark as the highest level of Isolations and solves all of the concurrency problems